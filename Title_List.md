## 100-Day Title List

## ðŸŸ¦ Phase 0 â€” System Thinking Foundations (Days 1â€“7)

**Day 01** â€” What a Data Structure Really Is  
**Day 02** â€” Why Storage Is the First System Problem  
**Day 03** â€” Why CRUD Is the Only Honest Mental Model  
**Day 04** â€” Operations vs Data: What Actually Costs  
**Day 05** â€” Cost Models: CPU, Memory, Cache, Pointers  
**Day 06** â€” Why Time Complexity Exists (Intuition Only)  
**Day 07** â€” What Makes a Data Structure Good or Bad

---

## ðŸŸ¦ Phase 1 â€” Linear Structures (Days 8â€“35)

### Arrays

**Day 08** â€” Why Arrays Exist  
**Day 09** â€” Contiguous Memory and Its Consequences  
**Day 10** â€” Reading from Arrays: Why Itâ€™s Fast  
**Day 11** â€” Insertion Costs: Why Arrays Hurt  
**Day 12** â€” Deletion and Shifting Costs  
**Day 13** â€” Dynamic Arrays and Resizing Strategies  
**Day 14** â€” Cache Locality and Why Arrays Win  
**Day 15** â€” JS Arrays vs Real Arrays  
**Day 16** â€” Implementing an Array from Scratch  
**Day 17** â€” When Arrays Break Down

---

### Strings

**Day 18** â€” Why Strings Are a Data Structure  
**Day 19** â€” Immutability and Copy Cost  
**Day 20** â€” Copy vs Reference Semantics  
**Day 21** â€” Concatenation Costs at Scale  
**Day 22** â€” Designing with Strings Safely

---

### Linked Lists

**Day 23** â€” Why Linked Lists Were Invented  
**Day 24** â€” Memory Layout of Linked Lists  
**Day 25** â€” Pointer Overhead and Indirection Cost  
**Day 26** â€” Singly Linked List: CRUD Costs  
**Day 27** â€” Doubly Linked List: Tradeoffs  
**Day 28** â€” Insertions vs Traversals  
**Day 29** â€” Cache Misses and Why Lists Are Slow  
**Day 30** â€” Why Linked Lists Lose to Arrays  
**Day 31** â€” When (Rarely) Linked Lists Make Sense

---

### Phase 1 Synthesis

**Day 32** â€” Arrays vs Linked Lists: Reality vs Theory  
**Day 33** â€” Choosing Linear Structures by Constraints  
**Day 34** â€” Failure Modes of Linear Storage  
**Day 35** â€” Phase 1 Retrospective: What You Actually Learned

---

## ðŸŸ¦ Phase 2 â€” Controlled Access & Fast Lookup (Days 36â€“70)

### Stacks

**Day 36** â€” Why Access Restrictions Exist  
**Day 37** â€” Stack as a Constraint, Not a Container  
**Day 38** â€” Call Stack as a Real System Structure  
**Day 39** â€” Stack Overflow: What Really Happens  
**Day 40** â€” Implementing Stacks: Array vs List

---

### Queues

**Day 41** â€” Why Queues Exist  
**Day 42** â€” Simple Queue Implementations  
**Day 43** â€” Why Naive Queues Fail Under Load  
**Day 44** â€” Circular Queues and Fixed Buffers  
**Day 45** â€” Event Loop as a Queue  
**Day 46** â€” Backpressure and Queue Failure

---

### Hash Tables

**Day 47** â€” Why Key-Value Storage Exists  
**Day 48** â€” Hashing as an Idea (Not Math)  
**Day 49** â€” What Makes a Good Hash Function  
**Day 50** â€” Collisions Are Unavoidable  
**Day 51** â€” Collision Handling Strategies  
**Day 52** â€” Load Factor and Performance Decay  
**Day 53** â€” Resizing and Rehashing Costs  
**Day 54** â€” Implementing a Hash Table from Scratch  
**Day 55** â€” Delete Operations and Tombstones  
**Day 56** â€” JS Objects vs Maps  
**Day 57** â€” Why Redis Behaves the Way It Does  
**Day 58** â€” Hash Tables in APIs and Caching

---

### Phase 2 Synthesis

**Day 59** â€” Choosing Between Stack, Queue, and Hash Map  
**Day 60** â€” Constant-Time Is an Illusion  
**Day 61** â€” Failure Modes at Scale  
**Day 62** â€” Designing with Access Patterns  
**Day 63** â€” Memory vs Speed Tradeoffs  
**Day 64** â€” Common Backend Mistakes  
**Day 65** â€” Phase 2 Retrospective

---

## ðŸŸ¦ Phase 3 â€” Trees as Storage Engines (Days 66â€“100)

### Tree Fundamentals

**Day 66** â€” Why Trees Exist at All  
**Day 67** â€” Hierarchical vs Sequential Data  
**Day 68** â€” Why Databases Donâ€™t Use Arrays  
**Day 69** â€” Nodes, Edges, and Structural Cost

---

### Binary Search Trees

**Day 70** â€” Why Ordered Data Is Hard  
**Day 71** â€” Binary Search Tree Basics  
**Day 72** â€” Insert and Search in BST  
**Day 73** â€” Deletion and Structural Changes  
**Day 74** â€” Unbalanced Trees and Degenerate Cases  
**Day 75** â€” Why BST Performance Degrades  
**Day 76** â€” Visualizing Tree Shape Changes  
**Day 77** â€” CRUD Costs in Trees

---

### Why Balancing Exists

**Day 78** â€” The Pain That Created Balanced Trees  
**Day 79** â€” Why AVL / Red-Black Trees Were Invented  
**Day 80** â€” Read-Heavy vs Write-Heavy Trees  
**Day 81** â€” Trees vs Hash Tables

---

### Real Systems Perspective

**Day 82** â€” Trees in Databases (Conceptual)  
**Day 83** â€” Indexes as Tree Structures  
**Day 84** â€” File Systems as Trees  
**Day 85** â€” Memory Overhead of Trees  
**Day 86** â€” Cache Behavior in Trees

---

### Final Synthesis & Transition

**Day 87** â€” Choosing Trees vs Hash Tables  
**Day 88** â€” When Trees Are the Wrong Choice  
**Day 89** â€” End-to-End CRUD Comparison  
**Day 90** â€” Failure Modes Across All Structures  
**Day 91** â€” Designing Storage for Real Systems  
**Day 92** â€” Linear â†’ Non-Linear Thinking Shift  
**Day 93** â€” Why Algorithms Now Make Sense  
**Day 94** â€” Mapping Structures to Real Products  
**Day 95** â€” Designing APIs with Data Constraints  
**Day 96** â€” Common Web Dev DSA Mistakes  
**Day 97** â€” How to Read System Design Problems  
**Day 98** â€” Preparing for Algorithms (Correctly)  
**Day 99** â€” What You Know That Most Donâ€™t  
**Day 100** â€” Foundation Complete
